---
import Html from "../layout/html.astro";
---
<Html>
	<section>
		<div class="input-area">
			<div>search</div>
			<input type="text" class="search" name="search" id="search" />
		</div>
		<h2>results</h2>
		<ul class="search-result"></ul>
	</section>
</Html>

<script>
import { createIndexFromObject, search, StaticSeekError } from "staticseek";
import type { SearchResult, StaticSeekIndex } from "staticseek";
import type { SearchKey } from "./searchindex.json.ts";

function generateSearchFunction(result_element: HTMLElement) {
	const STATE = {
		NOT_INITIALIZED: 0,
		FETCHING: 1,
		INITIALIZED: 2
	} as const;
	type STATE = typeof STATE[keyof typeof STATE];

	let state : number = STATE.NOT_INITIALIZED;
	let index: StaticSeekIndex;

	return async (search_text: string) : Promise<SearchResult[] | null> => {
		const start = performance.now();
		if(state !== STATE.INITIALIZED) {
			if(state === STATE.FETCHING) return null;
			state = STATE.FETCHING;
			result_element.innerText = "Loading search index...";
			const response = await fetch("/searchindex.json");
			if(!response.ok) {
				console.error("fail to fetch index: " + response.statusText);
				result_element.innerText = "";
				state = STATE.NOT_INITIALIZED;
				return null;
			}
			const response_json = await response.json()
			const staticseek_index = createIndexFromObject(response_json);
			if(staticseek_index instanceof StaticSeekError) {
				console.error(staticseek_index);
				result_element.innerText = "";
				state = STATE.NOT_INITIALIZED;
				return null;
			}
			index = staticseek_index;
			result_element.innerText = "";
			state = STATE.INITIALIZED;

			const query_results = await search(index, search_text);
			if(query_results instanceof StaticSeekError) {
				console.error(query_results);
				return null;
			}

			console.log(`search time: ${performance.now() - start}ms`);
            console.log(`index size: ${new Blob([JSON.stringify(response_json)]).size} byte.`);
			return query_results;
		}

		const query_results = await search(index, search_text);
		if(query_results instanceof StaticSeekError) {
			console.error(query_results);
			return null;
		}

		console.log(`search time: ${performance.now() - start}ms`);
		return query_results;
	};
}

function generateResultHTMLElement(search_results: SearchResult[]): HTMLLIElement[] {
	const result = search_results.map(sr => {
		const post = sr.key as SearchKey;	// ad-hock solution. you might as well use zod or something like that to validate the key.
		if(!post.data.title || !post.id) throw new Error("title or id is not found in the search result.");

		const li = document.createElement("li");

		const h3 = document.createElement("h3");
		h3.appendChild(document.createTextNode(post.data.title));

		const a = document.createElement("a");
		a.setAttribute("href", `/posts/${post.id}`);
		a.appendChild(h3);

		const p = document.createElement("p");
		p.appendChild(document.createTextNode(sr.refs[0].wordaround ?? ""));

		li.appendChild(a);
		li.appendChild(p);

		return li;
	});

	return result;
}

const text   = document.querySelector<HTMLInputElement>('.search');
const result = document.querySelector<HTMLElement>('.search-result');
if(!text || !result) throw new Error("text or result is not found");

const search_function = generateSearchFunction(result);

text?.addEventListener('input', async () =>
{
	const search_results = await search_function(text.value);

	if(text.value.length === 0) {
		result.innerText = "";
		return;
	} else {
		if(search_results) {
			result.innerText = "";
			if(search_results.length === 0) {
				result.innerText = "No results found.";
			} else {
				generateResultHTMLElement(search_results).map((e) => result.appendChild(e));
			}
		}
	}
});
</script>
