---
import Html from "../layout/html.astro";
---
<Html>
	<section>
		<div class="input-area">
			<div>search</div>
			<input type="text" class="search" name="search" id="search" />
		</div>
		<h2>results</h2>
		<ul class="search-result"></ul>
	</section>
</Html>

<script>
import { createIndexFromObject, search, StaticSeekError } from "staticseek";
import type { SearchResult, StaticSeekIndex } from "staticseek";
import type { SearchKey } from "./searchindex.json.ts";

function generateSearchFunction(result_element: HTMLElement) {
	const STATE = {
		NOT_INITIALIZED: 0,
		FETCHING: 1,
		INITIALIZED: 2
	} as const;
	type STATE = typeof STATE[keyof typeof STATE];

	let state : number = STATE.NOT_INITIALIZED;
	let index: StaticSeekIndex;

	return async (search_text: string) : Promise<SearchResult[] | null> => {
		if(state !== STATE.INITIALIZED) {
			if(state === STATE.FETCHING) return null;
			state = STATE.FETCHING;
			result_element.innerText = "loading search index...";
			const response = await fetch("/searchindex.json");
			const staticseek_index = createIndexFromObject(await response.json());
			if(staticseek_index instanceof StaticSeekError) throw staticseek_index;
			index = staticseek_index;
			result_element.innerText = "";
			state = STATE.INITIALIZED;
		}

		const query_results = await search(index, search_text);
		if(query_results instanceof StaticSeekError) {
			throw query_results;
		}

		return query_results;
	};
}

function generateResultHTMLElement(search_results: SearchResult[]): HTMLLIElement[] {
	const result = search_results.map(sr => {
		const post = sr.key as SearchKey;	// ad-hock solution. you might as well use zod or something like that to validate the key.
		if(!post.data.title || !post.id) throw new Error("title or id is not found in the search result.");

		const li = document.createElement("li");

		const h3 = document.createElement("h3");
		h3.appendChild(document.createTextNode(post.data.title));

		const a = document.createElement("a");
		a.setAttribute("href", `/posts/${post.id}`);
		a.appendChild(h3);

		const p = document.createElement("p");
		p.appendChild(document.createTextNode(sr.refs[0].wordaround ?? ""));

		li.appendChild(a);
		li.appendChild(p);

		return li;
	});

	return result;
}

const text   = document.querySelector<HTMLInputElement>('.search');
const result = document.querySelector<HTMLElement>('.search-result');
if(!text || !result) throw new Error("text or result is not found");

const search_function = generateSearchFunction(result);

text?.addEventListener('input', async () =>
{
	const start = performance.now();
	if(text.value) {
		const search_results = await search_function(text.value);

		if(search_results && search_results.length !== 0) {
			result.innerText = "";
			generateResultHTMLElement(search_results).map((e) => result.appendChild(e));
		} else if(search_results !== null) {
			result.innerText = "not found";
		}
		console.log(`search time: ${performance.now() - start}ms`);
	}
});
</script>
