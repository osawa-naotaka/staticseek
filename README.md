# unisearch.js: 軽量でそこそこ速い、静的サイトのための全文検索エンジン
## 概要
unisearch.jsは静的サイト向けに作られた、完全クライアントサイドの全文検索エンジンです。任意のJavaScriptオブジェクト配列内にある文字列および文字列の配列を検索することができます。検索対象の記事をJavaScriptオブジェクト化することで、サーバーサイドの実装なしに全文検索機能を静的サイト上で実現することができます。

unisearch.jsは非常に簡単に使用することができます。検索のために必要なコードを以下に示します。コードはほんのわずかしか必要ありません。

```
import { LinearIndex, createIndex, search, UniSearchError } from "unisearch";

const index = createIndex(LinearIndex, array_of_articles);
if (!(index instanceof UniSearchError)) {
        const result = search(index, ”search word”);
 }
```

unisearch.jsは検索に必要な一通りの機能を備えています。完全一致検索のほか、あいまい検索機能も備えます。さらに、and検索、or検索、not検索、フィールドを限定した検索、スコアリングのウェイト指定の機能があります。Google likeの検索文字列を使うことができ、直感的です。検索結果はTF-IDFというスコアリング方法を元にソートされ、一致箇所周辺の文字列とともに検索結果が得られます。

unisearch.jsはそこそこ高速です。Wikipediaの記事1000個ほど、総サイズ20Mbyte程度に対する完全一致検索は数msec程度で、あいまい検索は100msec程度で完了します。あいまい検索機能を限定することで、さらに大量の記事を検索対象にできます。

unisearch.jsは、unicodeで表すことのできる全ての言語を対象に検索できます。一般的な正規化や日本語特有の正規化、グラフェム単位の検索により、漢字の異字体や絵文字に対しても正しく検索できます。

unisearch.jsは他のJavaScriptライブラリに依存していないため、あなたのサイトに簡単に埋め込むことができます。


## つかいかた

unisearch.jsは、インデックスの作成と、インデックスを用いた検索、の2ステップをふむことで検索を実現します。インデックス作成はページ読み込み時に1回だけ行い、検索のたびにインデックスを使い回します。

### インデックスの作成
インデックスを作成する関数の型を以下に示します。

```
export function createIndex<T>(
    index_class: IndexClass,
    contents: unknown[],
    env: SearchEnv = {},
): UniIndex<SearchIndex<T>> | UniSearchError;

export type SearchEnv = {
    field_names?: Record<FieldName, Path>;
    key_field?: Path;
    search_targets?: Path[];
    weight?: number;
    distance?: number;
};
```

index_classには全文検索で使用するアルゴリズムをクラスで指定します。通常はLinearIndexクラスを指定します。contentsは検索対象のJavaScriptオブジェクトの配列を指定します。検索対象は、このオブジェクトのうち、文字列のフィールドか、文字列の配列のフィールドに限られます。また、文字列のフィールドまでの間に配列のフィールドが挟まる場合は、そのフィールドが文字列であっても検索対象に含まれません。

関数の戻り値は作成されたインデックスです。指定されたcontentsやenvに問題がある場合は、UniSearchErrorを返します。インデックスすると指定されたフィールドがない場合にエラーが発生します。

検索を行った結果は、配列のインデックスとして得られます。追加で、その検索オブジェクトに属する文字列を検索結果として返すこともできます。例えば記事のslugなどを設定することで、検索結果の利用をより容易にできます。

検索結果に任意の文字列フィールドを含めるには、createIndex関数のenv引数に、keyフィールドを指定します。keyフィールドには、オブジェクトのルートからkeyフィールドへ向かうパスをドットで区切った文字列として指定します。以下のようなオブジェクト構成でslugをkeyに指定する例を示します。

```
const index = createIndex(LinearIndex, array_of_articles, {key: 'meta.slug'});
```

インデックスには、標準で与えられたオブジェクトのテキストフィールド全てをそのまま含みます。そのため、インデックスサイズは検索対象の文章の総サイズにおおむね等しくなります。httpプロトコルではgzip圧縮がなされると思いますが、それでも10Mbyteを超えるような総文章量の場合は、Local Storageを利用してインデックスを保存するなどの工夫が必要となるでしょう。インデックスをjsonファイルとして分離し、検索時に動的にfetchするなどの工夫も必要となります。

また、前述のように、インデックスには全ての文章が含まれるため、本名や住所などのセンシティブな情報を検索対象に含めることは十分に注意してください。

インデックスに含めるフィールドを限定することもできます。指定はenv引数のsearch_targetsフィールドに配列として指定してください。


```
const index = createIndex(LinearIndex, array_of_articles, {search_targets: ['title','description','meta.categories']});
```

インデックスの作成を事前に作成して、ページ読み込み時の処理量を削減することもできます。静的サイトジェネレータ(SSG)を用いる場合、デプロイ時にインデックスを作成し、jsonファイルとして配置することで、クライアント側からfetchを利用したインデックスの読み込みが可能になります。htmlファイルへのバンドルサイズが削減でき、検索を実行しない場合の読み込み時間を短縮てきます。

インデックスをJavaScriptオブジェクトに変換するには、indexToObject関数を使います。

```
const json = JSON.stringify(indexToObject(index));
```

また、JavaScriptオブジェクトからindexを再構築するにはcreateIndexFromObject関数を使います。

```
const resp = await fetch(index_url);
const index = createIndexFromObject(resp.json());
```

### インデックスを用いた検索
インデックスを作成したあとは、同じインデックスを使って何度も検索を実行できます。

```
export function search<T>(index: UniIndex<SearchIndex<T>>, query: string): SearchResult[] | UniSearchError;
```

クエリは文字列としてインデックスとともにsearch関数に与えます。クエリの書式はおおむねGoogle検索の書式に類似しています。

- あいまい検索

unisearch.jsは標準であいまい検索を行います。あいまい検索では、デフォルトで1文字の間違い(編集距離)まで許容します。間違いの文字数を増やすには、「distance:2 検索文字列」のように、検索文字列の前に許容する間違いの数を正の整数で与えます。distanceとコロンと整数の間にはスペースをあけず、整数と検索文字列をあとはスペースをあけます。以下、検索文字列にオプションを指定する場合は同様のフォーマットを使います。

毎回設定するのではなく、一律で編集距離を設定するには、インデックス作成時にenv引数のdistanceフィールドに指定する編集距離を設定します。また、編集距離を0にすることで、あいまい検索を無効化できます。

```
const index = createIndex(LinearIndex, array_of_articles, {distance: 2});
```

- 完全一致検索

完全一致検索を行うには、「”検索文字列”」のように、検索文字列をダブルクォーテーションで囲います。ダブルクォーテーションの中にスペースを含めた場合、そのスペース込みで完全一致検索を行います。ダブルクォーテーションの中はエスケープシーケンスに対応し、ダブルクォーテーション自体を検索文字列に加えるには「\”」と入力します。

- and検索

「検索文字列1 検索文字列2」のように、検索文字列を空白で区切ることにより、両方の文字列を含む文章を検索します。空白は、いわゆる全角スペース、半角スペース、タブ、改行など、unicodeにおける一通りの空白に対応します。

- not検索

検索ワードの前に「-検索文字列1 検索文字列2」「-”検索文字列1” 検索文字列2」のようにマイナスをつけることで、その文字列を含まない文章を検索することができます。この例では、検索文字列1を含まず、検索文字列2を含む文章が検索されます。not検索は常にand検索と一緒に使われます。not検索が単体で使われた場合には、その検索ワードは無視されます。

- or検索

検索文字列同士を「検索文字列1 OR 検索文字列2」のように、空白で区切られた大文字のORで区切ることにより、検索文字列1と検索文字列2のどちらか一方、または両方が含まれた文章を検索します。結合の強さはandがorより強く、例えば「検索文字列1 検索文字列2 OR 検索文字列3」は、検索文字列1とを両方含む文章、または、検索文字列3を含む文章が検索されます。


- 検索フィールド限定

インデックスした文章全てを検索対象とせず、一部のみを検索対象とすることができます。例えば、前の例でtitleフィールドだけ検索対象に含めるには、「from:title 検索文字列」と入力します。from:直後のフィールド指定は、デフォルトでフィールドへのパス文字列の最後を指します。例えば、「meta.slug」を指定するには、「from:slug 検索文字列」と入力します。

- スコアの重み変更

例えば、「from:title weight:2.5 検索文字列」とすることで、titleフィールドで検索文字列を検索し、そのスコアを2.5倍します。weight:直後には正の整数または小数が指定できます。from:を指定しなくても動作し、その場合は指定されたキーワードに該当する文章のスコアが2.5倍されます。


### 検索結果
検索結果はSearchResult型の配列として得られます。

```
export type SearchResult = {
    id: number;
    key: string | null;
    score: number;
    refs: Reference[];
};
```
idフィールドは、一致した文章の配列インデックスを返します。インデックス作成時の配列インデックスです。keyフィールドは、インデックス作成時に指定したフィールドが設定されます。scoreはTF-IDFに基づいた値が設定されます。検索ワード個々のTF-IDFの合算値になり、編集距離が増えるごとに1/xで減じられていきます。

refsフィールドは、検索で一致した箇所の情報の配列が設定されます。

```
export type Reference = {
    token: string;
    path: Path;
    pos?: number;
    wordaround?: string;
    distance: number;
};
```
tokenにはクエリ中の個々の検索文字列が設定されます。pathはどのフィールドから検索ワードが見つかったかをフィールドへのパスで示します。posは一致した箇所への、文章の先頭からの文字数です。完全一致検索の場合は、グラフェムを正しくカウントしないため、少し位置がずれます。wordaroundは、一致した箇所の前後の文字が指定されます。distanceは、あいまい検索にて一致した場合の編集距離が指定されます。

## 高速検索用インデックスの作成


